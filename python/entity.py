from dataclasses import dataclass
from random import randint
import EC_operation as ec
from common_parameters import Parameters
from EC_operation import ECCPoint
from typing import Dict
from typing import List
import hash_func as hash
import eec

### ====================== KGC CLASS

@dataclass
class KGC:
    '''Class holding the KGC entity'''
    
    def __setup__(self):
        '''
        Run by KGC
        Generate system necessary parameters for cryptographic scheme
        Return a class of Parameters
        '''
        # Code below is provided by course staffs
        # ------ STEP 1
        # Using the secp256k1 elliptic curve equation: yË†2 = xË†3 + 7
        # Prime of the finite field
        # Necessary parameters for the cryptographic operations
        P: int = (
            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
        )

        field = ec.PrimeGaloisField(prime=P)

        A: int = 0
        B: int = 7

        curve256k1 = ec.EllipticCurve(
            a=A,
            b=B,
            field=field
        )   

        # I = ec.ECCPoint(x = None, y = None, curve = curve256k1)    # where I is a point at Infinity

        # Generator point of the chosen group
        G = ec.ECCPoint(
            x = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798,
            y = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8,
            curve = curve256k1
        )

        # Order of the group generated by G, such that nG = I
        q = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141

        # ----- STEP 2 + 3
        # master secret key x and public key P_pub
        x = randint(0, q)
        P_pub = G.__rmul__(x)

        # ----- STEP 4
        # I implement a hash function in a separate file: hash_func.py
        H0 = hash.HASH_FUNC_DICT['H0']
        H1 = hash.HASH_FUNC_DICT['H1']

        # package all parameters into a class holder
        common_para = Parameters(x,G,q,P_pub,H0,H1,ec.I,P)

        return common_para

    def __gen_partial_key__(self,common_para: Parameters,
                            id_d_i: str,P_i: ec.ECCPoint):
        '''
        Run by KGC
        Generate a partial key pair for each drone d_i
        Return R_i, s_i
        '''
        x,q,G,H0 = common_para.x, common_para.q, common_para.G, common_para.H0

        # ---- STEP 1
        # choose a secret value
        r_i = randint(0,q)

        # ---- STEP 2
        # partial public key
        R_i = G.__rmul__(r_i)

        # ---- STEP 3
        # partial secret key
        hash_feed = ','.join(list(map(str, [id_d_i, R_i, P_i])))
        s_i = r_i + x * H0(hash_feed, q) % q

        # save R_i and s_i into variables of class Edge_Drone d_i
        # d_i.s_i = s_i
        # d_i.R_i = R_i

        return R_i, s_i

### ==================== DRONE CLASS

@dataclass
class Drone:
    id: str
    x_i: int = None # secret value
    P_i: ECCPoint = None # public key
    s_i: int = None # partial secret key
    R_i: ECCPoint = None # partial public key

    def __gen_secret_value__(self,q,G):
        '''
        Run by each edge drone and a team leader
        Generate a pair of secret/public key for each edge drone d_i or team leader
        '''
        # ---- STEP 1
        # generate a secret key
        x_i = randint(0,q)

        # ---- STEP 2
        # compute corresponding public key
        P_i = G.__rmul__(x_i)

        self.x_i = x_i
        self.P_i = P_i

        return x_i, P_i

    def __full_key_gen__(self):
        '''
        Run by each registered drone
        Generate full key pair for each drone
        in the format: (partial_key, key)
        '''
        assert self.R_i != None
        assert self.P_i != None
        assert self.x_i != None
        assert self.s_i != None

        # full private key
        full_priv_key = (self.s_i, self.x_i)

        # full public key
        full_pub_key = (self.R_i, self.P_i)

        return full_priv_key, full_pub_key

    def __sign_mess__(self,mess: str, sys_para: Parameters):
        '''Sign a message using ECDSA
        Reference: https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm#Signature_generation_algorithm'''
        
        # order n of base point
        n = sys_para.q
        # hash output of the message
        z = e = hash.H1(mess)
        
        while True:
            # ----- STEP 3
            k = randint(1,n)
            new_point = sys_para.G.__rmul__(k)
            x1 = new_point.x.value

            r = x1 % n
            if r == 0:
                # if r == 0 go back to STEP 3
                continue

            inverse_k = eec.mod_inverse(k,n)
            s = (inverse_k * (z + r * self.x_i)) % n
            if s != 0:
                # if s == 0 go back to STEP 3
                # else break the loop
                break
        
        return r,s

    def __verify_mess__(self, mess: str, r: int,s: int ,public_key: ECCPoint,
                        sys_para: Parameters):
        '''Verify a signed message using ECDSA
        Reference: https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm#Signature_verification_algorithm'''
        
        # preliminary test
        # not a identity element

        identity_point = sys_para.I
        assert public_key.x != identity_point.x or public_key.y != identity_point.y
        
        # verifying process
        n = sys_para.q
        assert r >= 1 and r < n
        assert s >= 1 and s < n

        z = e = hash.H1(mess)
        inverse_s = eec.mod_inverse(s,n)
        u1 = (z * inverse_s) % n
        u2 = (r * inverse_s) % n

        point1 = sys_para.G.__rmul__(u1)
        point2 = public_key.__rmul__(u2)
        new_point = point1.__add__(point2)

        if (new_point.x == identity_point.x and
            new_point.y == identity_point.y):
            return False

        if r != new_point.x.value % n:
            return False

        return True

### =================== EDGE_DRONE CLASS

@dataclass
class Edge_Drone(Drone):
    '''Class holding edge drone'''

    K_g: int = None # group key
    q_k: "Leader" = None # team leader

    def __assign_leader__(self, leader: "Leader"):
        self.q_k = leader

    def __key_retrieval__(self,V: ECCPoint,cipher_list, t_g, para: Parameters):
        '''Run by each edge drone d_i'''
        # ------- STEP 1
        T_i = V.__rmul__(self.x_i + self.s_i)

        # verify computation of T_i and Y_i, two components of K_g, were
        # correctly computed
        assert para.G.__rmul__((self.s_i + self.x_i)*self.q_k.l_k) == self.q_k.Y_i_list[self.id].__rmul__(self.q_k.l_k)

        # ------- STEP 2
        h1_hash_feed = ','.join(list(map(str, [V,T_i,self.q_k.id,self.q_k.R_i,self.q_k.P_i,
                                                self.id,self.R_i,self.P_i,t_g])))
        K_g = cipher_list[self.id] ^ para.H1(h1_hash_feed)

        # verify the group key is identical in all drones
        assert K_g == self.q_k.K_g

        self.K_g = K_g
        return K_g

### ======================== TEAM LEADER CLASS

@dataclass
class Leader(Drone):
    '''Class holding a team leader drone'''
    # x_i: int # secret value
    # P_i: ec.ECCPoint # public key

    K_g: int = None # group key
    l_k: int = None # random number for distributing group key
    V: ECCPoint = None
    Y_i_list: Dict[str, ECCPoint] = None

    drone_list: List[Drone] = None

    def __random_number__(self):
        return randint(1,1000000000000)

    def __register_drone__(self, edge_drone: Edge_Drone):
        '''Append a given drone to its drone list'''
        assert edge_drone != None
        self.drone_list.append(edge_drone)
        edge_drone.__assign_leader__(self)

        # re-generate a new group key whenever a new drone is added

    def __remove_key__(self, id: str):
        '''Remove a drone with a given id'''
        assert id != ''
        for drone in self.drone_list:
            if drone.id == id:
                self.drone_list.remove(drone)

                # re-generate a new group key whenever an existing drone is removed

    def __gen_group_key__(self, common_para: Parameters, t: int):
        '''
        Run by team leader
        Generate a symmetric group session key
        '''
        self.Y_i_list = {}

        q,G,H0,H1,P_pub = [common_para.q, common_para.G, common_para.H0,
                        common_para.H1,common_para.P_pub]

        # ----- STEP 1
        K_g = randint(0,q)
        l_k = randint(0,q)

        self.K_g = K_g
        self.l_k = l_k

        # ----- STEP 2
        V = G.__rmul__(l_k)
        self.V = V

        cipher_lists = {}

        for drone in self.drone_list:
            # ----- STEP 3
            R_i, P_i = drone.R_i, drone.P_i

            # ----- STEP 4
            h0_hash_feed = ','.join(list(map(str, [drone.id, R_i, P_i])))
            Y_i = P_i.__add__(R_i.__add__(P_pub.__rmul__(H0(h0_hash_feed, q))))

            self.Y_i_list[drone.id] = Y_i
            
            T_i = Y_i.__rmul__(l_k)
            h1_hash_feed = ','.join(list(map(str, [V,T_i,self.id,self.R_i,self.P_i,
                                                drone.id,drone.R_i,drone.P_i,t])))

            C_i = K_g ^ H1(h1_hash_feed)
            cipher_lists[drone.id] = C_i

        return V, cipher_lists

    def __re_key__(self, common_para: Parameters, new_drone: Drone, t: int):
        '''Re-generate group key whenever a new drone joins or an
        existing drone leaves'''

        q,P_pub,H0,H1 = common_para.q, common_para.P_pub,common_para.H0,common_para.H1

        # ----- STEP 1
        temp_key = randint(0,q)
        while K_g != None and temp_key == K_g:
            temp_key = randint(0,q)
        K_g = temp_key

        # ----- STEP 2
        if new_drone != None:
            R_i, P_i = new_drone.R_i, new_drone.P_i
            h0_hash_feed = ','.join(list(map(str, [new_drone.id,R_i,P_i])))
            Y_i = P_i.__add__(R_i.__add__(P_pub.__rmul__(H0(h0_hash_feed,q))))
            T_i = Y_i.__rmul__(self.l_k)

        cipher_list = {}

        # ----- STEP 3
        for drone in self.drone_list:
            h1_hash_feed = ','.join(list(map(str, [self.V,T_i,self.id,self.R_i,self.P_i,
                                                drone.id,drone.R_i,drone.P_i,t])))
            C_i = K_g ^ H1(h1_hash_feed)
            cipher_list[drone.id] = C_i

        return self.V, cipher_list